---
title: Javascript入门到精通学习记录
tags: 
- 碎碎念
toc: true
date: 2025-08-12 23:55:22
type: normal
description: 学习的一点记录，与实际我在笔记软件上写的不一样
---
# 结论在前
我去你的这书是真老东西啊，看看基本的语法得了
# 前四章
唯一的收获是Java里的常量使用final修饰
# 第五章
在Java中，字符串的类名为String（**开头大写**）
有以下函数：
1. 重载了加号，可以直接使用+链接字符串与其他变量，最后转换为统一的字符串
2. .trim()方法：去除空格
3. startwith，endwith方法：判断首尾元素
4. equal方法来判断相等，因为正常的字符串变量是引用。
5. compairto方法：字典序比较
6. split：分割，参数可以传递特定字符串也可以是正则表达式
7. format方法：格式化，类似于printf的格式化
字符串生成器：可变字符串，类似python
# 第六章
数组是原生的数据类型，但是还有一个Arrays类包含了一些必要的函数，如sort，copyOfRange
1. binarysearch
# 第七章
### 类与对象
对象：具有数据结构和对应函数实现的具体单位（单位即可以由java某个关键字调用的整体）
类：对于一部分（或者尚未存在）的对象的性质的抽象描述，包括度量数据与行为方法。
封装：对于类的数据权限的问题，有一些中间变量本不应该由用户查看/修改，防止出错。
多态：同一个概念随着对象的不同对应的有多种本质不同的表现形态。
### 类与权限
权限修饰符：public，protected，private，与cpp相同
构造函数：不需要返回类型的同名函数
静态类型：支持直接使用类名.变量名的方式使用，而不用非得对象.变量名
静态方法同理，支持直接类名引用。
对于java的观念来看，我们可以认为static的内容都是属于类的，与特定的对象无关，所有的对象共享所有静态资源。
### 对象与引用
实际上所用的变量名本质上都是引用，类似C语言的指针，因此需要特别的函数来比较对象，来区别引用之间的关系。
Java有完整的垃圾回收机制，当一个对象离开作用域或者被置为null的时候，内存将被回收，不用专门回收内存了。
# 第八章
没啥用啊
# 九章
更没啥用了，需要的时候查表得了
# 第十章
抽象类：在正常的父类子类的特征继承关系之上的一层抽象处理，抽象到方法需要依赖其子类存在，因此**不可以实例化对象**。
抽象方法：没有方法体的方法，换句话说只有声明。
以上两个概念均使用abstract关键字修饰
直觉上的理解，类的继承就像是“概念”的包含关系，而抽象类就像是“形式”，不可能包含实体。

接口：为了解决java只能继承一个类，抽象类的内容难以接入的问题所定义的一种函数形式，本质是抽象方法。
但是定义任何类时都可以使用implement关键字为类单独定义接口中的所有方法。
> 不是这设计的什么玩意啊

# 十一章
java如同cpp的库函数一样，提供了一些整体程序的链接调用，不同于cpp的库函数实际上就是一堆函数单独拉了一个文件拼接起来，命名冲突靠引入命名空间解决，java的类包同时实现了统一的引入和命名管理，不同包之间具有包含关系，包本身也会隔离命名。
包的定义：在写文件的时候，将package关键字语句设置为第一行非注释语句。
包的引入：import关键字可以详细到包，也可以到方法。
> java的函数传参可以使用final关键字来保证参数本身不被修改，是一种安全措施。

final关键字还能被定义于方法与类中，final方法不可被修改，final类不能被继承，可以看成继承链的“final”。
类的嵌套：内部类
内部类可以在类内部定义，作用域也仅限于类之中，具有修饰符。
内部类可以自由访问外部类**所有**的内容，外部类不能访问没有权限的内部类成员。
一个继承了某个接口的类实例，除了作为类本身，还可以作为一个接口的实例使用。
# 14，15章
说实话和cpp没差多少……不如实际写个程序实在。
# 17章
枚举：枚举的出现主要是为了安全，即为变量限制到一些固定的取值，当多人使用代码时保证不会出现未定义行为。
泛型这块好像没啥好说的，和cpp的模板如出一辙，知识拓展到了类里面去。
泛型的extend关键字对泛型类型作出限制，只有实现了指定的接口或者继承了指定的类才能使用。
# 18章
多线程：在windows里，每一个包含其自己地址的程序就是一个进程，系统为这些进程分配一定的cpu时间来保证运行性能的充分使用。
### 继承thread类的线程写法
thread类是java内置的线程类，每一个继承了的类都是一个可以运行的类。
* 线程所有的运行内容都放在run()方法内部，这是java神秘的嵌套设计模式带来的优势
* 线程内部往往写成while（1）的形式，由系统调度分配系统资源
### 使用runable接口的线程写法
一个runable对象
使用runnable对象实例化thread
star启动线程
> 有点疑惑……那线程属于哪个层级了

### 线程的操作
1. sleep：一段时间内不参与线程的资源分配和运行。
2. join：在一个线程里中断并先执行另一个线程
3. 中断：使用while（）循环里的break使用
4. 线程具有优先级，优先级较高的线程将会被优先执行——虽然目前我还不知道这代表什么
5. 线程同步机制：对于一些使用共用资源的线程，数据安全检测和执行可能中间会隔断导致安全检测失效。因此存在同步机制，保证某一部分程序连续运行（同时只有一个线程运行同步的部分）。
# 后续内容
后边一些叽里呱啦的说什么呢，泛而不精。不管了，这些内容之后会有专门的学习过程。